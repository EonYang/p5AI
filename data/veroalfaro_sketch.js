Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
let data;
let story1;
let story2;
let story3;
let story4;
let story5;
let story6;
let story7;
let story8;
let story9;
let story10;
let story11;
let story12;
let story13;
let story14;
let story15;
let story16;
let story17;
let story18;
let story19;
let story20;
let story21;
let story22;
let story23;
let story24;
let story25;
let story26;
let story27;
let story28;
let story29;
let story30;
let story31;
let story32;
let story33;
let story34;
let story35;
let story36;
let soundFX;
function preload(){
data = loadSound('36_out_of_100.mp3');
story1 = loadSound('story_1.mp3');
story2 = loadSound('story_2.mp3');
story3 = loadSound('story_3.mp3');
story4 = loadSound('story_4.mp3');
story5 = loadSound('story_5.mp3');
story6 = loadSound('story_6.mp3');
story7 = loadSound('story_7.mp3');
story8 = loadSound('story_8.mp3');
story9 = loadSound('story_9.mp3');
story10 = loadSound('story_10.mp3');
story11 = loadSound('story_11.mp3');
story12 = loadSound('story_12.mp3');
story13 = loadSound('story_13.mp3');
story14 = loadSound('story_14.mp3');
story15 = loadSound('story_15.mp3');
story16 = loadSound('story_16.mp3');
story17 = loadSound('story_17.mp3');
story18 = loadSound('story_18.mp3');
story19 = loadSound('story_19.mp3');
story20 = loadSound('story_20.mp3');
story21 = loadSound('story_21.mp3');
story22 = loadSound('story_22.mp3');
story23 = loadSound('story_23.mp3');
story24 = loadSound('story_24.mp3');
story25 = loadSound('story_25.mp3');
story26 = loadSound('story_26.mp3');
story27 = loadSound('story_27.mp3');
story28 = loadSound('story_28.mp3');
story29 = loadSound('story_29.mp3');
story30 = loadSound('story_30.mp3');
story31 = loadSound('story_31.mp3');
story32 = loadSound('story_32.mp3');
story33 = loadSound('story_33.mp3');
story34 = loadSound('story_34.mp3');
story35 = loadSound('story_35.mp3');
story36 = loadSound('story_36.mp3');
}
function setup() {
createCanvas(1024, 768);
soundFX = [data, story1, story2, story3, story4, story5, story6, story7, story8, story9, story10,story11, story12, story13, story14, story15, story16, story17, story18, story19, story20, story21, story22, story23, story24, story25, story26, story27, story28, story29, story30, story31, story32, story33, story34, story35, story36];
}
function draw() {
background(0,0,0);
}
for (var i = 0; i < portList.length; i++) {
}
}
for (let i = 1; i < soundFX.length; i++) {
soundFX[i].stop();
}
}
soundFX[0].stop();
}
soundFX[0].loop();
}
soundFX[1].play();
}
soundFX[2].play();
}
soundFX[3].play();
}
soundFX[4].play();
}
soundFX[5].play();
}
soundFX[6].play();
}
soundFX[7].play();
}
soundFX[8].play();
}
soundFX[9].play();
}
soundFX[10].play();
}
soundFX[11].play();
}
soundFX[12].play();
}
soundFX[13].play();
}
soundFX[14].play();
}
soundFX[15].play();
}
soundFX[16].play();
}
soundFX[17].play();
}
soundFX[18].play();
}
soundFX[19].play();
}
soundFX[20].play();
}
soundFX[21].play();
}
soundFX[22].play();
}
soundFX[23].play();
}
soundFX[24].play();
}
soundFX[25].play();
}
soundFX[26].play();
}
soundFX[27].play();
}
soundFX[28].play();
}
soundFX[29].play();
}
soundFX[30].play();
}
soundFX[31].play();
}
soundFX[32].play();
}
soundFX[33].play();
}
soundFX[34].play();
}
soundFX[35].play();
}
soundFX[36].play();
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
let data;
let story1;
let story2;
let story3;
let story4;
let story5;
let story6;
let story7;
let story8;
let story9;
let story10;
let story11;
let story12;
let story13;
let story14;
let story15;
let story16;
let story17;
let story18;
let story19;
let story20;
let story21;
let story22;
let story23;
let story24;
let story25;
let story26;
let story27;
let story28;
let story29;
let story30;
let story31;
let story32;
let story33;
let story34;
let story35;
let story36;
let soundFX;
function preload(){
data = loadSound('36_out_of_100.mp3');
story1 = loadSound('story_1.mp3');
story2 = loadSound('story_2.mp3');
story3 = loadSound('story_3.mp3');
story4 = loadSound('story_4.mp3');
story5 = loadSound('story_5.mp3');
story6 = loadSound('story_6.mp3');
story7 = loadSound('story_7.mp3');
story8 = loadSound('story_8.mp3');
story9 = loadSound('story_9.mp3');
story10 = loadSound('story_10.mp3');
story11 = loadSound('story_11.mp3');
story12 = loadSound('story_12.mp3');
story13 = loadSound('story_13.mp3');
story14 = loadSound('story_14.mp3');
story15 = loadSound('story_15.mp3');
story16 = loadSound('story_16.mp3');
story17 = loadSound('story_17.mp3');
story18 = loadSound('story_18.mp3');
story19 = loadSound('story_19.mp3');
story20 = loadSound('story_20.mp3');
story21 = loadSound('story_21.mp3');
story22 = loadSound('story_22.mp3');
story23 = loadSound('story_23.mp3');
story24 = loadSound('story_24.mp3');
story25 = loadSound('story_25.mp3');
story26 = loadSound('story_26.mp3');
story27 = loadSound('story_27.mp3');
story28 = loadSound('story_28.mp3');
story29 = loadSound('story_29.mp3');
story30 = loadSound('story_30.mp3');
story31 = loadSound('story_31.mp3');
story32 = loadSound('story_32.mp3');
story33 = loadSound('story_33.mp3');
story34 = loadSound('story_34.mp3');
story35 = loadSound('story_35.mp3');
story36 = loadSound('story_36.mp3');
}
function setup() {
createCanvas(1024, 768);
soundFX = [data, story1, story2, story3, story4, story5, story6, story7, story8, story9, story10,story11, story12, story13, story14, story15, story16, story17, story18, story19, story20, story21, story22, story23, story24, story25, story26, story27, story28, story29, story30, story31, story32, story33, story34, story35, story36];
}
function draw() {
background(0,0,0);
}
for (var i = 0; i < portList.length; i++) {
}
}
for (let i = 1; i < soundFX.length; i++) {
soundFX[i].stop();
}
}
soundFX[0].stop();
}
soundFX[0].loop();
}
soundFX[1].play();
}
soundFX[2].play();
}
soundFX[3].play();
}
soundFX[4].play();
}
soundFX[5].play();
}
soundFX[6].play();
}
soundFX[7].play();
}
soundFX[8].play();
}
soundFX[9].play();
}
soundFX[10].play();
}
soundFX[11].play();
}
soundFX[12].play();
}
soundFX[13].play();
}
soundFX[14].play();
}
soundFX[15].play();
}
soundFX[16].play();
}
soundFX[17].play();
}
soundFX[18].play();
}
soundFX[19].play();
}
soundFX[20].play();
}
soundFX[21].play();
}
soundFX[22].play();
}
soundFX[23].play();
}
soundFX[24].play();
}
soundFX[25].play();
}
soundFX[26].play();
}
soundFX[27].play();
}
soundFX[28].play();
}
soundFX[29].play();
}
soundFX[30].play();
}
soundFX[31].play();
}
soundFX[32].play();
}
soundFX[33].play();
}
soundFX[34].play();
}
soundFX[35].play();
}
soundFX[36].play();
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
let data;
let story1;
let story2;
let story3;
let story4;
let story5;
let story6;
let story7;
let story8;
let story9;
let story10;
let story11;
let story12;
let story13;
let story14;
let story15;
let story16;
let story17;
let story18;
let story19;
let story20;
let story21;
let story22;
let story23;
let story24;
let story25;
let story26;
let story27;
let story28;
let story29;
let story30;
let story31;
let story32;
let story33;
let story34;
let story35;
let story36;
let soundFX;
function preload(){
data = loadSound('36_out_of_100.mp3');
story1 = loadSound('story_1.mp3');
story2 = loadSound('story_2.mp3');
story3 = loadSound('story_3.mp3');
story4 = loadSound('story_4.mp3');
story5 = loadSound('story_5.mp3');
story6 = loadSound('story_6.mp3');
story7 = loadSound('story_7.mp3');
story8 = loadSound('story_8.mp3');
story9 = loadSound('story_9.mp3');
story10 = loadSound('story_10.mp3');
story11 = loadSound('story_11.mp3');
story12 = loadSound('story_12.mp3');
story13 = loadSound('story_13.mp3');
story14 = loadSound('story_14.mp3');
story15 = loadSound('story_15.mp3');
story16 = loadSound('story_16.mp3');
story17 = loadSound('story_17.mp3');
story18 = loadSound('story_18.mp3');
story19 = loadSound('story_19.mp3');
story20 = loadSound('story_20.mp3');
story21 = loadSound('story_21.mp3');
story22 = loadSound('story_22.mp3');
story23 = loadSound('story_23.mp3');
story24 = loadSound('story_24.mp3');
story25 = loadSound('story_25.mp3');
story26 = loadSound('story_26.mp3');
story27 = loadSound('story_27.mp3');
story28 = loadSound('story_28.mp3');
story29 = loadSound('story_29.mp3');
story30 = loadSound('story_30.mp3');
story31 = loadSound('story_31.mp3');
story32 = loadSound('story_32.mp3');
story33 = loadSound('story_33.mp3');
story34 = loadSound('story_34.mp3');
story35 = loadSound('story_35.mp3');
story36 = loadSound('story_36.mp3');
}
function setup() {
createCanvas(1024, 768);
soundFX = [data, story1, story2, story3, story4, story5, story6, story7, story8, story9, story10,story11, story12, story13, story14, story15, story16, story17, story18, story19, story20, story21, story22, story23, story24, story25, story26, story27, story28, story29, story30, story31, story32, story33, story34, story35, story36];
soundFX[0].loop();
}
function draw() {
background(0,0,0);
}
for (var i = 0; i < portList.length; i++) {
}
}
for (let i = 0; i < soundFX.length; i++) {
soundFX[i].stop();
}
}
soundFX[1].play();
}
soundFX[2].play();
}
soundFX[3].play();
}
soundFX[4].play();
}
soundFX[5].play();
}
soundFX[6].play();
}
soundFX[7].play();
}
soundFX[8].play();
}
soundFX[9].play();
}
soundFX[10].play();
}
soundFX[11].play();
}
soundFX[12].play();
}
soundFX[13].play();
}
soundFX[14].play();
}
soundFX[15].play();
}
soundFX[16].play();
}
soundFX[17].play();
}
soundFX[18].play();
}
soundFX[19].play();
}
soundFX[20].play();
}
soundFX[21].play();
}
soundFX[22].play();
}
soundFX[23].play();
}
soundFX[24].play();
}
soundFX[25].play();
}
soundFX[26].play();
}
soundFX[27].play();
}
soundFX[28].play();
}
soundFX[29].play();
}
soundFX[30].play();
}
soundFX[31].play();
}
soundFX[32].play();
}
soundFX[33].play();
}
soundFX[34].play();
}
soundFX[35].play();
}
soundFX[36].play();
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
let data;
let story1;
let story2;
let story3;
let story4;
let story5;
let story6;
let story7;
let story8;
let story9;
let story10;
let story11;
let story12;
let story13;
let story14;
let story15;
let story16;
let story17;
let story18;
let story19;
let story20;
let story21;
let story22;
let story23;
let story24;
let story25;
let story26;
let story27;
let story28;
let story29;
let story30;
let story31;
let story32;
let story33;
let story34;
let story35;
let story36;
let soundFX;
function preload(){
data = loadSound('36_out_of_100.mp3');
story1 = loadSound('story_1.mp3');
story2 = loadSound('story_2.mp3');
story3 = loadSound('story_3.mp3');
story4 = loadSound('story_4.mp3');
story5 = loadSound('story_5.mp3');
story6 = loadSound('story_6.mp3');
story7 = loadSound('story_7.mp3');
story8 = loadSound('story_8.mp3');
story9 = loadSound('story_9.mp3');
story10 = loadSound('story_10.mp3');
story11 = loadSound('story_11.mp3');
story12 = loadSound('story_12.mp3');
story13 = loadSound('story_13.mp3');
story14 = loadSound('story_14.mp3');
story15 = loadSound('story_15.mp3');
story16 = loadSound('story_16.mp3');
story17 = loadSound('story_17.mp3');
story18 = loadSound('story_18.mp3');
story19 = loadSound('story_19.mp3');
story20 = loadSound('story_20.mp3');
story21 = loadSound('story_21.mp3');
story22 = loadSound('story_22.mp3');
story23 = loadSound('story_23.mp3');
story24 = loadSound('story_24.mp3');
story25 = loadSound('story_25.mp3');
story26 = loadSound('story_26.mp3');
story27 = loadSound('story_27.mp3');
story28 = loadSound('story_28.mp3');
story29 = loadSound('story_29.mp3');
story30 = loadSound('story_30.mp3');
story31 = loadSound('story_31.mp3');
story32 = loadSound('story_32.mp3');
story33 = loadSound('story_33.mp3');
story34 = loadSound('story_34.mp3');
story35 = loadSound('story_35.mp3');
story36 = loadSound('story_36.mp3');
}
function setup() {
createCanvas(1024, 768);
soundFX = [data, story1, story2, story3, story4, story5, story6, story7, story8, story9, story10,story11, story12, story13, story14, story15, story16, story17, story18, story19, story20, story21, story22, story23, story24, story25, story26, story27, story28, story29, story30, story31, story32, story33, story34, story35, story36];
soundFX[0].loop();
}
function draw() {
background(0,0,0);
}
for (var i = 0; i < portList.length; i++) {
}
}
for (let i = 0; i < soundFX.length; i++) {
soundFX[i].stop();
}
}
soundFX[1].play();
}
soundFX[2].play();
}
soundFX[3].play();
}
soundFX[4].play();
}
soundFX[5].play();
}
soundFX[6].play();
}
soundFX[7].play();
}
soundFX[8].play();
}
soundFX[9].play();
}
soundFX[10].play();
}
soundFX[11].play();
}
soundFX[12].play();
}
soundFX[13].play();
}
soundFX[14].play();
}
soundFX[15].play();
}
soundFX[16].play();
}
soundFX[17].play();
}
soundFX[18].play();
}
soundFX[19].play();
}
soundFX[20].play();
}
soundFX[21].play();
}
soundFX[22].play();
}
soundFX[23].play();
}
soundFX[24].play();
}
soundFX[25].play();
}
soundFX[26].play();
}
soundFX[27].play();
}
soundFX[28].play();
}
soundFX[29].play();
}
soundFX[30].play();
}
soundFX[31].play();
}
soundFX[32].play();
}
soundFX[33].play();
}
soundFX[34].play();
}
soundFX[35].play();
}
soundFX[36].play();
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
let data;
let story1;
let story2;
let story3;
let story4;
let story5;
let story6;
let story7;
let story8;
let story9;
let story10;
let soundFX;
function preload(){
data = loadSound('36_out_of_100.mp3');
story1 = loadSound('story_1.mp3');
story2 = loadSound('story_2.mp3');
story3 = loadSound('story_3.mp3');
story4 = loadSound('story_4.mp3');
story5 = loadSound('story_5.mp3');
story6 = loadSound('story_6.mp3');
story7 = loadSound('story_7.mp3');
story8 = loadSound('story_8.mp3');
story9 = loadSound('story_9.mp3');
story10 = loadSound('story_10.mp3');
}
function setup() {
createCanvas(1024, 768);
soundFX = [data, story1, story2, story3, story4, story5, story6, story7, story8, story9, story10];
soundFX[0].loop();
}
function draw() {
background(0,0,0);
}
for (var i = 0; i < portList.length; i++) {
}
}
for (let i = 0; i < soundFX.length; i++) {
soundFX[i].stop();
}
}
soundFX[1].play();
}
soundFX[2].play();
}
soundFX[3].play();
}
soundFX[4].play();
}
soundFX[5].play();
}
soundFX[6].play();
}
soundFX[7].play();
}
soundFX[8].play();
}
soundFX[9].play();
}
soundFX[10].play();
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
let data;
let story1;
let story2;
let story3;
let story4;
let story5;
let story6;
let story7;
let story8;
let story9;
let story10;
let soundFX;
function preload(){
data = loadSound('36_out_of_100.mp3');
story1 = loadSound('story_1.mp3');
story2 = loadSound('story_2.mp3');
story3 = loadSound('story_3.mp3');
story4 = loadSound('story_4.mp3');
story5 = loadSound('story_5.mp3');
story6 = loadSound('story_6.mp3');
story7 = loadSound('story_7.mp3');
story8 = loadSound('story_8.mp3');
story9 = loadSound('story_9.mp3');
story10 = loadSound('story_10.mp3');
}
function setup() {
createCanvas(1024, 768);
soundFX = [data, story1, story2, story3, story4, story5, story6, story7, story8, story9, story10];
soundFX[0].loop();
}
function draw() {
background(0,0,0);
}
for (var i = 0; i < portList.length; i++) {
}
}
soundFX[0].stop();
}
soundFX[1].stop();
soundFX[2].stop();
soundFX[3].stop();
soundFX[4].stop();
soundFX[5].stop();
soundFX[6].stop();
soundFX[7].stop();
soundFX[8].stop();
soundFX[9].stop();
soundFX[10].stop();
}
soundFX[1].play();
}
soundFX[2].play();
}
soundFX[3].play();
}
soundFX[4].play();
}
soundFX[5].play();
}
soundFX[6].play();
}
soundFX[7].play();
}
soundFX[8].play();
}
soundFX[9].play();
}
soundFX[10].play();
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
let side = 600;
let buttonValue=0;
let mySound;
let mySound1;
let soundFX;
function preload(){
mySound = loadSound('36_out_of_100.mp3');
mySound1 = loadSound('story_1.mp3');
}
function setup() {
createCanvas(1024, 768);
soundFX = [mySound, mySound1];
}
function draw() {
background(0,0,0);
}
for (var i = 0; i < portList.length; i++) {
}
}
soundFX[0].play();
}
}
void setup() {
}
void loop() {
}
}
let img1;
let img2;
let img3;
let img4;
let img5;
let img6;
let img7;
let img8;
let img9;
let img10;
let img11;
let img12;
let img13;
let images;
let randomImages;
function preload(){
data=loadJSON("tweets.json");
img1=loadImage("1");
img2=loadImage("2");
img3=loadImage("3");
img4=loadImage("4");
img5=loadImage("5");
img6=loadImage("6");
img7=loadImage("7");
img8=loadImage("8");
img9=loadImage("9");
img10=loadImage("10");
img11=loadImage("11");
img12=loadImage("12");
img13=loadImage("13");
}
function setup() {
createCanvas(400, 400);
images = [img1, img2, img3, img4, img5, img6, img7, img8, img9, img10, img11, img12, img13];
mousePressed();
}
function gotData(data) {
for (let i = 0; i < data.length; i++) {
text(data[i].tweet,20,20);
}
}
function mousePressed() {
if (mouseX < width && mouseY < height);
let randomImages = Math.floor(random(0, images.length));
console.log("NUM: "+randomImages, images);
image(images[randomImages], 0, 0);
}
function draw() {
background(220);
}let data;
let img1;
let img2;
let img3;
let img4;
let img5;
let img6;
let img7;
let img8;
let img9;
let img10;
let img11;
let img12;
let img13;
let img14;
function preload(){
data=loadJSON("kk_tweets.json");
}
function setup() {
createCanvas(400, 400);
console.log(JSON.stringify(data,null,null));
let txt = data.text;
let id = data.id;
for (let i = 0; i < text.length; i++) {
text(txt[i].text,20,20);
}
}
function draw() {
background(220);
}let video;
function setup() {
createCanvas(400, 400);
video = createCapture(VIDEO);
video.hide();
}
function draw() {
background(220);
image(video, 0,0,width, height);
loadPixels();
let mostRedX = 0;
let mostRedY = 0;
let mostRed= 0;
for(let y = 0; y < height; y++){
for( let x = 0; x < width; x++){
var currentRed = pixels[4*(y*width + x)];
var currentGreen = pixels[4*(y*width + x)+1];
var currentBlue = pixels[4*(y*width + x)+2];
if (currentRed > mostRed){
mostRedX=x;
mostRedY = y;
mostRed = currentRed;
}
}
}
updatePixels();
ellipse( mostRedX, mostRedY, 50);
}let mySound;
let button;
let amp;
function preload(){
mySound = loadSound('What_It_Is.mp3');
}
function setup() {
createCanvas(600, 580);
button= createButton ("play");
button.mousePressed(togglePlaying);
colorMode(HSB, 360, 100, 100, 100);
amp = new p5.Amplitude();
}
function togglePlaying(){
if (!mySound.isPlaying()){
mySound.play();
mySound.setVolume(0.3);
button.html("pause");
} else {
mySound.pause();
button.html("play");
}
}
function draw() {
var vol = amp.getLevel ();
console.log(vol);
background(225, 0, 0, 40);
let sinVal=sin(radians(frameCount));
let freq = 4;
let speed = 1;
let ampl = 40;
for(let i = 0; i < width; i += 5){
let y = sin(radians(i + frameCount * speed)*freq) * vol *400;
let dia = map(y,-vol *100, vol *400, 10, 3);
noStroke();
fill((sin(radians(frameCount))*122 + 123),100,100, 50);
ellipse(i, height / 2 + y, dia*2 , dia*2);
ellipse(i, height / 3 + y, dia/2 , dia/2);
ellipse(i, height - height /3 + y, dia/2 , dia/2);
let x = sin(radians(i + frameCount * speed)*freq) * vol *400;
ellipse(i, height / 6 + x, dia , dia);
ellipse(i, height - height/6 + x, dia , dia);
}
}let mySound;
let button;
let amp;
function preload(){
mySound = loadSound('What_It_Is.mp3');
}
function setup() {
createCanvas(600, 580);
button= createButton ("play");
button.mousePressed(togglePlaying);
colorMode(HSB, 360, 100, 100, 100);
amp = new p5.Amplitude();
}
function togglePlaying(){
if (!mySound.isPlaying()){
mySound.play();
mySound.setVolume(0.3);
button.html("pause");
} else {
mySound.pause();
button.html("play");
}
}
function draw() {
var vol = amp.getLevel ();
console.log(vol);
background(0, 50);
let sinVal=sin(radians(frameCount));
let freq = 3;
let speed = 0.4;
let ampl = 40;
for(let i = 0; i < width; i += 5){
let y = sin(radians(i + frameCount * speed)*freq) * ampl;
let dia = map(y,-ampl, ampl, 10, 3);
noStroke();
fill((sin(radians(frameCount))*122 + 123),100,100, 50);
ellipse(i, height / 2 + y, dia*3 , dia*3);
ellipse(i, height / 4 + y, dia , dia);
ellipse(i, height - height /4 + y, dia , dia);
let x = sin(radians(i + frameCount * speed)*freq) * ampl;
ellipse(i, height / 8 + x, dia*2 , dia*2);
ellipse(i, height - height/8 + x, dia*2 , dia*2);
}
}function setup() {
createCanvas(400, 400);
colorMode(HSB, 360, 100, 100, 100);
}
function draw() {
background(220);
let sinVal=sin(radians(frameCount));
fill((sin(radians(frameCount))*122 + 123),100,100);
ellipse(width/2, height/2, 100, 100);
}function setup() {
createCanvas(400, 400);
}
function draw() {
background(220);
let sinVal=sin(radians(frameCount));
let freq = 3;
let speed = 0.5;
let amp = sin (radians(frameCount))*20;
for(let i = 0; i < width; i += 5){
let y = sin(radians(i + frameCount * speed)*freq) * amp;
let absY = abs(y);
let dia = map(y,-amp, amp, 10, 3);
ellipse(i, height / 2 + absY, dia , dia);
ellipse(i, height / 4 + y, 5 , 5);
}
}let data;
function preload(){
data=   loadJSON("birth.json");
data2= loadJSON("coverage.json");
}
function setup() {
createCanvas(600, 600);
ellipseMode(CENTER);
fill(255,57,95);
noStroke();
ellipse(80,395,15,15);
noStroke();
fill(55,255,250);
ellipse(280,395,15,15);
console.log(JSON.stringify(data,null,null));
let fact = data.fact;
for (let i = 0; i < fact.length; i++) {
rectMode(CENTER);
noStroke();
fill (255,57,95);
rect(60+50*i, 200, 20, fact[i].Value*3);
let dims = fact[i].dims;
for (let j = 0; j < dims.length; j++) {
text(dims[j].REGION,20,20);
}
}
let fact2 = data2.fact2;
for (let i = 0; i < fact2.length; i++) {
rectMode(CENTER);
noStroke();
fill (55,255,250);
rect(80+50*i, 200, 20, fact2[i].Value*3);
console.log(fact2[i].Value);
let dims = fact2[i].dims;
for (let j = 0; j < dims.length; j++) {
fill(255);
text(dims[j].REGION,50 ,300);
textSize(12);
}
}
}
function draw() {
fill (255);
textSize(18);
text("Adolescent birth rate vs Access to Health by Region",10,30);
textSize(12);
text("Adolescent birth rate",100,400);
text("Access to Health",300,400);
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
let side = 600;
let buttonValue=0;
let mySound;
let mySound1;
let mySound2;
let mySound3;
let mySound4;
let mySound5;
let soundFX;
let randomSFX;
let bg;
function preload(){
mySound = loadSound('stopEating.mp3');
mySound1 = loadSound('cavityTime.mp3');
mySound2 = loadSound('diabetes.mp3');
mySound3 = loadSound('laugh1.mp3');
mySound4 = loadSound('laugh2.mp3');
mySound5 = loadSound('noNoNo.mp3');
}
function setup() {
bg = loadImage("candyv5.png");
createCanvas(1024, 768);
soundFX = [mySound, mySound1, mySound2, mySound3, mySound4, mySound5];
mousePressed();
}
function draw() {
background(bg);
rectMode(CENTER);
fill(255,0,0,0);
noStroke();
rect(1020/2, 1188/2,1400/2,725/2);
}
function mousePressed() {
if (mouseY > 820/2 && mouseX > 320/2 && mouseX < 1730/2){
buttonValue = 120
}else {
buttonValue = 10
}
console.log(buttonValue);
}
for (var i = 0; i < portList.length; i++) {
}
}
let randomSFX = Math.floor(random(0, soundFX.length));
console.log("NUM: "+randomSFX, soundFX);
soundFX[randomSFX].play();
}
}
void setup() {
}
void loop() {
}
}
function preload(){
data=   loadJSON("birth.json");
data2= loadJSON("coverage.json");
}
function setup() {
createCanvas(600, 600);
console.log(JSON.stringify(data,null,null));
let fact = data.fact;
for (let i = 0; i < fact.length; i++) {
rectMode(CENTER);
noStroke();
fill (0,0,255,90);
rect(50+50*i, 100, 20, fact[i].Value);
let dims = fact[i].dims;
for (let j = 0; j < dims.length; j++) {
text(dims[j].REGION,20,20);
}
}
let fact2 = data2.fact2;
for (let i = 0; i < fact2.length; i++) {
rectMode(CENTER);
noStroke();
fill (255,0,0,90);
rect(50+50*i, 100, 20, fact2[i].Value);
console.log(fact2[i].Value);
let dims = fact2[i].dims;
for (let j = 0; j < dims.length; j++) {
fill(255);
text(dims[j].REGION,20,20);
textSize(32);
}
}
}
function draw() {
fill (255);
textSize(15);
text("Adolescent birth rate vs Access to Health by Region",20,20);
let apiKey = "c061a490098848d3b6e1ddc8efe48f10";
let urls = [];
let snnipets = [];
let input;
function setup() {
createCanvas(800,500);
let query = "sexual harassment";
let startDate= `20171001`;
let endDate= `20181001`;
let url = `${baseUrl}?api-key=${apiKey}&q=${query}&begin_date=${startDate}&end_date=${endDate}`;
loadJSON(url, gotData);
}
function gotData(data){
let res = data.response.docs;
for (let i=0; i<res.length; i++){
const url = res[i].web_url;
const title = res[i].snippet;
urls.push(url);
snnipets.push(title);
}
console.log(urls);
console.log(snnipets);
showArticles();
}
function showArticles(){
background(0);
const fontsize=0;
background (0);
textSize(fontsize);
for( let i = 0; i<titles.length; i++){
const dispText= titles[i] + "/n" + urls[i]
fill(255);
text(dispText,10, i*40 + 80);
}
}
function draw(){
background (0);
}let data;
function preload(){
data=   loadJSON("birth.json");
}
function setup() {
createCanvas(400, 400);
console.log(JSON.stringify(data,null,null));
let fact = data.fact;
for (let i = 0; i < fact.length; i++) {
rectMode(CENTER);
rect(random(width), random(height), fact[i].Value, fact[i].Value);
console.log(fact[i].Value);
let dims = fact[i].dims;
for (let j = 0; j < dims.length; j++) {
text(dims[j].REGION,20,20);
}
}
}
function draw() {
let txt;
let button;
function setup() {
createCanvas(400, 400);
txt = select("#text");
button = select("#button");
button.mousePressed(loadIt);
}
function loadIt() {
console.log(txt.value());
}
function drawWeather(data) {
console.log(data.main.temp);
setTimeout(loadIt, 5000);
}
function draw() {
background(220);
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
let side = 600;
let buttonValue=0;
let mySound;
let mySound1;
let mySound2;
let mySound3;
let mySound4;
let mySound5;
let soundFX;
let randomSFX;
function preload(){
mySound = loadSound('stopEating.mp3');
mySound1 = loadSound('cavityTime.mp3');
mySound2 = loadSound('diabetes.mp3');
mySound3 = loadSound('laugh1.mp3');
mySound4 = loadSound('laugh2.mp3');
mySound5 = loadSound('noNoNo.mp3');
}
function setup() {
createCanvas(side, side);
soundFX = [mySound, mySound1, mySound2, mySound3, mySound4, mySound5];
mousePressed();
}
function draw() {
background(0,0,0);
rectMode(CENTER);
fill(255,0,0);
rect(side/2, side/2,300,300);
}
function mousePressed() {
if (mouseY > 150 && mouseY < 450 && mouseX > 150 && mouseX < 450){
buttonValue = 180
}else {
buttonValue = 0
}
}
for (var i = 0; i < portList.length; i++) {
}
}
randomSFX = Math.floor(random(0, soundFX.length));
console.log("NUM: "+randomSFX);
soundFX[randomSFX].play();
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
let side = 600;
let buttonValue=0;
let mySound;
function preload(){
mySound = loadSound('stopEating.mp3');
}
function setup() {
createCanvas(side, side);
mousePressed();
}
function draw() {
background(0,0,0);
rectMode(CENTER);
fill(255,0,0);
rect(side/2, side/2,300,300);
}
function mousePressed() {
if (mouseY > 150 && mouseY < 450 && mouseX > 150 && mouseX < 450){
mySound.play();
buttonValue = 179
}else {
buttonValue = 0
}
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
}
}
function preload(){
data=   loadJSON("birth.json");
}
function setup() {
createCanvas(400, 400);
console.log(JSON.stringify(data,null,null));
let fact = data.fact;
for (let i = 0; i < fact.length; i++) {
rectMode(CENTER);
rect(random(width), random(height), fact[i].Value, fact[i].Value);
console.log(fact[i].Value);
let dims = fact[i].dims;
for (let j = 0; j < dims.length; j++) {
createElement ("h1", dims[j].REGION);
}
}
}
function draw() {
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
let side = 600;
var buttonValue = 0;
function setup() {
createCanvas(side, side);
mouseDragged();
}
function draw() {
background(0,0,0);
rectMode(CENTER);
fill(255,0,0);
rect(side/2, side/2,300,300);
}
function mouseDragged(){
if (mouseY > 150 && mouseY < 450 && mouseX > 150 && mouseX < 450) {
buttonValue = 179
}else {
buttonValue = 0 
}
console.log(buttonValue);
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
let side = 600;
let buttonValue=0;
function setup() {
createCanvas(side, side);
}
function draw() {
background(0,0,0);
rectMode(CENTER);
fill(255,0,0);
rect(side/2, side/2,300,300);
if (mouseY > 150 && mouseY < 450 && mouseX > 150 && mouseX < 450){
if (mouseIsPressed) {
buttonValue = 179
console.log(buttonValue); 
}else {
buttonValue = 0
}
}
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
let slider;
let side = 600;
let black = 0;
function setup() {
createCanvas(side, side);
slider = padding  
}
function draw() {
background(sliderC);
rectMode(CENTER);
fill(255,0,0);
rect(width/2, height/2,300,300);
mappedMouse= map(sliderC, black,white,0,179);
background(0,0,0);
fill (255);
ellipseMode (CENTER);
ellipse (slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
function setup() {
createCanvas(600, 600);
}
function draw() {
background(0,0,0);
rectMode(CENTER);
fill(255,0,0);
rect(width/2, height/2,300,300);
mappedMouse= map(mouseX, 0,600,0,179);
}
function mousePressed(){
if (mouseX>250 && mouseX
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
}
}
let i =0;
function setup() {
createCanvas(400, 400);
loadStrings("lines.txt", doText);
}
function doText(data) {
lines = data;
}
function draw() {
background(220);
text(lines[i],5,20*i+20);
}
function mousePressed() {
i++;
console.log(lines[i]);
}function setup() {
createCanvas(400, 400);
setTimeout(drawSomething,500);
}
function draw() {
}
function drawSomething(){
ellipse(width/2,height/2,50,50);
}
Introduction to Physical Computing
ITP
This sketch will send 2 values as ascii from P5 to arduino
See arduino code in bottom, have LED connected to pin 3 and 5
function setup() {
createCanvas(255, 255);
}
function draw() {
background(0,0,255);
}
function MousePressed(){
}
for (var i = 0; i < portList.length; i++) {
}
}
var firstValueToSend = mouseX;
var secondValueToSend = mouseY;
}
void setup() {
}
void loop() {
analogWrite(3, firstValue);
analogWrite(5, secondValue);   
}
}
Introduction to Physical Computing
ITP
This sketch will send 2 values as ascii from P5 to arduino
See arduino code in bottom, have LED connected to pin 3 and 5
function setup() {
createCanvas(255, 255);
}
function draw() {
background(0,0,255);
var firstValueToSend = mouseX;
var secondValueToSend = mouseY;
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
analogWrite(3, firstValue);
analogWrite(5, secondValue);   
}
}
Introduction to Physical Computing
ITP
This sketch will send 2 values in ascii from arduino to P5
function setup() {
createCanvas(320, 240);
}
function draw() {
}
for (var i = 0; i < portList.length; i++) {
}
}
}
}
void setup() {
}
void loop() {
int valueToSend = analogRead(A0)/4;
valueToSend = analogRead(A1)/4;
delay (10);
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from arduino to P5
let cylinders = [];
let thediv;
let theotherdiv;
let h1;
let myButton;
function setup() {
myButton=createButton("Generate new cylinder");
myButton.mousePressed(myButtonCallback);
createDiv('');
createCanvas(600, 600, WEBGL);
}
function myButtonCallback(){
myButton.style("color","purple");
alert("Congratulations: You added a cylinder to the array!");
}
function draw() {
camera( 700,0,((height/2)/tan(PI/6)),camX,0,0,0,1,0);
background(0);
for ( let i = 0; i< cylinders.length; i++){
cylinders[i].display ();
}
}
function mousePressed () {
let p = new Cylinder (10 ,random(50,1000));
cylinders.push(p);
}
class Cylinder{
constructor(xx, yy, rr){
this.x=xx;
this.y=yy;
this.r=rr
}
display(){
directionalLight(0,219,255,1,1,0);
directionalLight(0,19,255,-1,-1,0);
directionalLight(0,255,103,-1,1,0);
directionalLight(192,0,255,1,-1,0);
specularMaterial(255);
}
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
byte byteToSend = map (analogValue, 0, 1023, 0, 255);
delay(50);
}
let theotherdiv;
let h1;
function setup() {
createCanvas(400, 400);
theotherdiv=createDiv("Here is the initial text");
thediv = select("#thediv");
thediv.html("Here is new text");
h1= createElement("h1", "Here is a headline");
h1.mousePressed(h1Callback);
two = select("#two");
}
function h1Callback(){
h1.style("color","green");
alert("Hey stop");
}
function draw() {
background(220);
}
function mousePressed(){
thediv.html("Here is some new text");
two.html("New Stuff");
Introduction to Physical Computing
ITP
This sketch will send one binary byte from arduino to P5
let cylinders = [];
function setup() {
createCanvas(600, 600, WEBGL);
}
function draw() {
camera( 700,0,((height/2)/tan(PI/6)),camX,0,0,0,1,0);
background(0);
for ( let i = 0; i< cylinders.length; i++){
cylinders[i].display ();
}
}
function mousePressed () {
let p = new Cylinder (10 ,random(50,1000));
cylinders.push(p);
}
class Cylinder{
constructor(xx, yy, rr){
this.x=xx;
this.y=yy;
this.r=rr
}
display(){
directionalLight(0,219,255,1,1,0);
directionalLight(0,19,255,-1,-1,0);
directionalLight(0,255,103,-1,1,0);
directionalLight(192,0,255,1,-1,0);
specularMaterial(255);
}
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
byte byteToSend = map (analogValue, 0, 1023, 0, 255);
delay(50);
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from arduino to P5
let cylinders = [];
function setup() {
createCanvas(600, 600, WEBGL);
}
function draw() {
camera( 700,0,((height/2)/tan(PI/6)),camX,0,0,0,1,0);
background(0);
for ( let i = 0; i< cylinders.length; i++){
cylinders[i].display ();
}
}
function mousePressed () {
let p = new Cylinder (10 ,random(50,1000));
cylinders.push(p);
}
class Cylinder{
constructor(xx, yy, rr){
this.x=xx;
this.y=yy;
this.r=rr
}
display(){
directionalLight(0,219,255,1,1,0);
directionalLight(0,19,255,-1,-1,0);
directionalLight(0,255,103,-1,1,0);
directionalLight(192,0,255,1,-1,0);
specularMaterial(255);
}
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
byte byteToSend = map (analogValue, 0, 1023, 0, 255);
delay(50);
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from arduino to P5
let cylinders = [];
function setup() {
createCanvas(600, 600, WEBGL);
}
function draw() {
camera( 500,0,((height/2)/tan(PI/6)),camX,0,0,0,1,0);
background(0);
noFill();
strokeWeight(1);
stroke(255,255,255,100);
for ( let i = 0; i< cylinders.length; i++){
cylinders[i].display ();
}
}
function mousePressed () {
let p = new Cylinder (20,20);
cylinders.push(p);
}
class Cylinder{
constructor(xx, yy, rr){
this.x=xx;
this.y=yy;
this.r=rr
}
display(){
noFill();
stroke(255);
normalMaterial();
}
move(){
push(); 
rotateX(frameCount/200);
rotateY(frameCount/200);
rotateZ(frameCount/200);
pop();
}
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
byte byteToSend = map (analogValue, 0, 1023, 0, 255);
delay(50);
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from arduino to P5
function setup() {
createCanvas(600, 600, WEBGL);
}
function draw() {
noFill();
strokeWeight(1);
stroke(255,255,255,100);
background(0);
push(); 
rotateX(frameCount/100);
rotateY(frameCount/100);
rotateZ(frameCount/100);
pop();
push(); 
rotateX(frameCount/100);
rotateY(frameCount/100);
rotateZ(frameCount/100);
pop();
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
byte byteToSend = map (analogValue, 0, 1023, 0, 255);
delay(50);
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from arduino to P5
let circles = [];
let fr=60;
function setup() {
createCanvas(600, 600);
frameRate(fr);
}
function draw() {
for ( let i = 0; i< circles.length; i++){
circles[i].display ();
circles[i].mirror ();
}
background(0,0,0,2);
}
function mouseDragged () {
let r = random (0.1,5);
let c = new Circle (mouseX,mouseY,r);
circles.push(c);
}
for (var i = 0; i < portList.length; i++) {
}
}
}
class Circle {
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
let col=0
let bri=0
colorMode(HSB,360,100,100,100);
fill(col,100,100,80);
noStroke();
ellipseMode(CENTER);
ellipse( (this.x)-this.d, (this.y)-this.d,this.d);
}
mirror(){
ellipse( width - ((this.x)-this.d), (this.y)-this.d, this.d);
ellipse( (this.x)-this.d, height-((this.y)-this.d),this.d);
ellipse( width-((this.x)-this.d), height-((this.y)-this.d),this.d);    
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
byte byteToSend = map (analogValue, 0, 1023, 0, 255);
delay(50);
}
Introduction to Physical Computing
ITP
This sketch will send one value in ascii from arduino to P5
function setup() {
createCanvas(320, 240);
}
function draw() {
background(255);
}
for (var i = 0; i < portList.length; i++) {
}
}
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
delay(50);
}
Introduction to Physical Computing
ITP
This sketch will send one value as ascii from P5 to arduino
See arduino code in bottom, have LED connected to pin 3
function setup() {
createCanvas(255, 255);
}
function draw() {
background(0,0,255);
var valueToSend = mouseX;
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
}
}
Introduction to Physical Computing
ITP
This sketch will send one binary byte from arduino to P5
var posX=0,posY=0, step = 10;
function setup() {
createCanvas(320, 240);
}
function draw() {
background(255);
rectMode(CENTER);
colorMode(HSB,360,100,100,100);
}
for (var i = 0; i < portList.length; i++) {
}
}
}
void setup() {
}
void loop() {
int analogValue = analogRead(A0);
byte byteToSend = map (analogValue, 0, 1023, 0, 255);
delay(50);
}
let fr=60;
function setup() {
frameRate(fr);
createCanvas(600, 600);
}
function draw() {
for ( let i = 0; i< circles.length; i++){
circles[i].display ();
circles[i].mirror ();
}
background(0,0,0,2);   
}
function mouseDragged () {
let r = random (0.1,5);
let c = new Circle (mouseX,mouseY,r);
circles.push(c);
}
class Circle {
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
let col=0
let bri=0
colorMode(HSB,360,100,100,100);
col = map(mouseX,0,width,190,125);
bri = map(mouseY, 0, height, 100,20);
fill(col,100,bri,80);
noStroke();
ellipseMode(CENTER);
ellipse( (this.x)-this.d, (this.y)-this.d,this.d);
}
mirror(){
ellipse( width - ((this.x)-this.d), (this.y)-this.d, this.d);
ellipse( (this.x)-this.d, height-((this.y)-this.d),this.d);
ellipse( width-((this.x)-this.d), height-((this.y)-this.d),this.d);
}
}let long;
let lat;
let total = 20;
let dots = [];
function setup() {
createCanvas(600, 600, WEBGL);
dots = make2Darray (long, lat);
for ( let i = 0; i< long; i++){
for (let j= 0; j <lat; j++){
dots [i][j] = new Dot(i,j,0)
}
}    
}
function draw() {
strokeWeight(5);
stroke(255,255,255);
background(0);
for ( let i = 0; i< dots.length; i++){
for (let j= 0; j <lat; j++){
dots[i][j].display();
}
}
}
function make2Darray (long, lat){
let arr= new Array (long);
for (let i = 0; i< arr.length; i++){
arr[i]= new Array(lat);
}
return arr;
}
class Dot {
constructor(xx, yy, zz){
this.x=xx;
this.y=yy;
this.z=zz
}
display(){
let r = 200;
for (let i = 0; i <total; i++);{
long = map(i,0,total,-PI, PI);
for (let j = 0; j<total; j++){
lat = map (j,0,total,-HALF_PI,HALF_PI);
this.x = r*sin(long)*cos(lat);
this.y = r*sin(long)*sin(lat);
this.z = r*cos(long);
}
}
point(this.x, this.y, this.z);
}
}function setup() {
createCanvas(600, 600, WEBGL);
}
function draw() {
noFill();
strokeWeight(1);
stroke(255,255,255,10);
background(0);
push(); 
rotateX(frameCount/100);
rotateY(frameCount/100);
rotateZ(frameCount/100);
sphere(200,24,16);
pop();
}let circles = [];
let fr=60;
function setup() {
frameRate(fr);
createCanvas(600, 600);
}
function draw() {
for ( let i = 0; i< circles.length; i++){
circles[i].display ();
circles[i].mirror ();
}
drawSomething(width/2,height/2,mouseX);
background(0,0,0,12);
}
function mouseDragged () {
let r = random (1,10);
let c = new Circle (mouseX,mouseY,r);
circles.push(c);
}
class Circle {
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
let col=0
col = map(mouseX,0,width,0,255);
stroke(col,col-100,col+100);
strokeWeight(1);
ellipseMode(CENTER);
ellipse( (mouseX+this.x)-this.d, (mouseY+this.y)-this.d,this.d);
}
mirror(){
ellipse( width - ((mouseX+this.x)-this.d), (mouseY+this.y)-this.d, this.d);
ellipse( (mouseX+this.x)-this.d, height-((mouseY+this.y)-this.d),this.d);
ellipse( width-((mouseX+this.x)-this.d), height-((mouseY+this.y)-this.d),this.d);
}
}
function drawSomething (x,y,s) {
ellipseMode(CENTER);
fill(0,0,0,1);
strokeWeight(0.2);
stroke(15,15,15);
ellipse(x,y,s,s);
if(s>10){
drawSomething(x,y,s-30);
}
}let circles = [];
let fr=60;
function setup() {
frameRate(fr);
createCanvas(600, 600);
}
function draw() {
for ( let i = 0; i< circles.length; i++){
circles[i].display ();
circles[i].mirror ();
}
drawSomething(width/2,height/2,mouseX);
background(0,0,0,12);
}
function mouseDragged () {
let r = random (1,10);
let c = new Circle (mouseX,mouseY,r);
circles.push(c);
}
class Circle {
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
let col=0
col = map(mouseX,0,width,0,255);
stroke(col,col-100,col+100);
strokeWeight(1);
ellipseMode(CENTER);
ellipse( (mouseX+this.x)-this.d, (mouseY+this.y)-this.d,this.d);
}
mirror(){
ellipse( width - ((mouseX+this.x)-this.d), (mouseY+this.y)-this.d, this.d);
ellipse( (mouseX+this.x)-this.d, height-((mouseY+this.y)-this.d),this.d);
ellipse( width-((mouseX+this.x)-this.d), height-((mouseY+this.y)-this.d),this.d);
}
}
function drawSomething (x,y,s) {
ellipseMode(CENTER);
fill(0,0,0,1);
strokeWeight(0.2);
stroke(15,15,15);
ellipse(x,y,s,s);
if(s>10){
drawSomething(x,y,s-30);
}
}let lines = [];
let fr=60;
function setup() {
frameRate(fr);
createCanvas(600, 600);
for ( let i = 0; i < 10; i++){
let x = 10*i;
let y = 30*i;
let long = 10+ 30*i;
lines[i]= new Line (x,y,long);
}
}
function draw() {
for ( let i = 0; i< lines.length; i++){
lines[i].display ();
lines[i].mirror ();
}
drawSomething(width/2,height/2,mouseX);
background(0,0,0,12);
}
class Line{
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
let col=0
col = map(mouseX,0,width,0,255);
stroke(col,col-100,col+100);
strokeWeight(1);
line( (mouseX+this.x)-this.d, (mouseY+this.y)-this.d,mouseX+this.x,mouseY+this.y);
}
mirror(){
line( width - ((mouseX+this.x)-this.d), (mouseY+this.y)-this.d, width-(mouseX+this.x), mouseY+this.y);
line( (mouseX+this.x)-this.d, height-((mouseY+this.y)-this.d),mouseX+this.x, height-(mouseY+this.y));
line( width-((mouseX+this.x)-this.d), height-((mouseY+this.y)-this.d),width-(mouseX+this.x), height-(mouseY+this.y));
}
}
function drawSomething (x,y,s) {
ellipseMode(CENTER);
fill(0,0,0,1);
strokeWeight(0.2);
stroke(15,15,15);
ellipse(x,y,s,s);
if(s>10){
drawSomething(x,y,s-30);
}
}function setup() {
createCanvas(400, 400);
}
function draw() {
background(220);
}
class Vector{
constructor(xx, yy){
this.x = xx;
this.y = yy;
}
create(){
this.current = createVector(this.x,this.y);
this.previous = createVector(this.x,this.y);
}
}let l1,l2,l3,l4;
let fr=60;
function setup() {
frameRate(fr);
createCanvas(600, 600);
l1 = new Line(0,0,50);
l2 = new Line(10,30,100);
l3 = new Line(20,60,200);
l4 = new Line(30,90,300);
}
function draw() {
l1.display();
l1.mirror();
l2.display();
l2.mirror();
l3.display();
l3.mirror();
l4.display();
l4.mirror();
drawSomething(width/2,height/2,mouseX);
background(0,0,0,12);
}
class Line{
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
let col=0
col = map(mouseX,0,width,0,255);
stroke(col,col-100,col+100);
strokeWeight(1);
line( (mouseX+this.x)-this.d, (mouseY+this.y)-this.d,mouseX+this.x,mouseY+this.y);
}
mirror(){
line( width - ((mouseX+this.x)-this.d), (mouseY+this.y)-this.d, width-(mouseX+this.x), mouseY+this.y);
line( (mouseX+this.x)-this.d, height-((mouseY+this.y)-this.d),mouseX+this.x, height-(mouseY+this.y));
line( width-((mouseX+this.x)-this.d), height-((mouseY+this.y)-this.d),width-(mouseX+this.x), height-(mouseY+this.y));
}
}
function drawSomething (x,y,s) {
ellipseMode(CENTER);
fill(0,0,0,1);
strokeWeight(0.2);
stroke(15,15,15);
ellipse(x,y,s,s);
if(s>10){
drawSomething(x,y,s-30);
}
}let l1,l2,l3,l4;
let fr=120;
function setup() {
frameRate(fr);
createCanvas(400, 400);
l1 = new Line(0,0,25);
l2 = new Line(10,30,50);
l3 = new Line(20,60,100);
l4 = new Line(30,90,200);
}
function draw() {
l1.display();
l1.mirror();
l2.display();
l2.mirror();
l3.display();
l3.mirror();
l4.display();
l4.mirror();
drawSomething(width/2,height/2,mouseX);
background(0,0,0,5);
}
class Line{
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
let col=0
col = map(mouseX,0,width,0,255);
stroke(col,col-100,col+100);
strokeWeight(1);
line( (mouseX+this.x)-this.d, (mouseY+this.y)-this.d,mouseX+this.x,mouseY+this.y);
}
mirror(){
line( width - ((mouseX+this.x)-this.d), (mouseY+this.y)-this.d, width-(mouseX+this.x), mouseY+this.y);
line( (mouseX+this.x)-this.d, height-((mouseY+this.y)-this.d),mouseX+this.x, height-(mouseY+this.y));
line( width-((mouseX+this.x)-this.d), height-((mouseY+this.y)-this.d),width-(mouseX+this.x), height-(mouseY+this.y));
}
}
function drawSomething (x,y,s) {
ellipseMode(CENTER);
noFill();
strokeWeight(0.2);
stroke(0,0,0);
ellipse(x,y,s,s);
if(s>10){
drawSomething(x,y,s-30);
}
}let l1,l2,l3,l4;
let fr=120;
function setup() {
frameRate(fr);
createCanvas(400, 400);
l1 = new Line(0,0,25);
l2 = new Line(10,30,50);
l3 = new Line(20,60,100);
l4 = new Line(30,90,200);
}
function draw() {
l1.display();
l1.mirror();
l2.display();
l2.mirror();
l3.display();
l3.mirror();
l4.display();
l4.mirror();
background(0,0,0,5);
}
class Line{
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
stroke(72,255,250);
line( (mouseX+this.x)-this.d, (mouseY+this.y)-this.d,mouseX+this.x,mouseY+this.y);
}
mirror(){
line( width - ((mouseX+this.x)-this.d), (mouseY+this.y)-this.d, width-(mouseX+this.x), mouseY+this.y);
line( (mouseX+this.x)-this.d, height-((mouseY+this.y)-this.d),mouseX+this.x, height-(mouseY+this.y));
line( width-((mouseX+this.x)-this.d), height-((mouseY+this.y)-this.d),width-(mouseX+this.x), height-(mouseY+this.y));
}
}let l1,l2,l3,l4;
function setup() {
createCanvas(400, 400);
l1 = new Line(200,200,50);
l2 = new Line(200,200,100);
l3 = new Line(200,200,200);
l4 = new Line(200,200,25);
}
function draw() {
l1.display();
l1.mirror();
l2.display();
l2.mirror();
l3.display();
l3.mirror();
l4.display();
l4.mirror();
background(220,220,220,10);
}
class Line{
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
line( mouseX-this.d, mouseY-this.d,mouseX,mouseY);
}
mirror(){
line( width - (mouseX-this.d), mouseY-this.d, width-mouseX, mouseY);
line( mouseX-this.d, height-(mouseY-this.d),mouseX, height-mouseY);
line( width-(mouseX-this.d), height-(mouseY-this.d),width-mouseX, height-mouseY);
}
}let b1;
function setup() {
createCanvas(400, 400);
b1 = new Bubble(200,200,20);
}
function draw() {
background(220);
ellipseMode(CENTER);
b1.display();
b1.mirror();
}
class Bubble{
constructor(xx, yy, dd){
this.x=xx;
this.y=yy;
this.d=dd
}
display(){
ellipse(mouseX,mouseY,this.d);
}
mirror(){
ellipse( width - mouseX, mouseY, width - mouseX, mouseY, );
}
}function setup() {
createCanvas(400, 400);
}
function draw() {
background(220);
rectMode(CENTER);
drawSomething(mouseX,mouseY,50);
}
function drawSomething (x,y,s) {
rect(x,y,s,s);
if(s>10){
drawSomething(x,y,s-10);
}
}
let b, b1;
function setup() {
createCanvas(400, 400);
b = new Ball(50,50,1,2,50);
b1 = new Ball(90,80,2,1,40);
}
function draw() {
background(220);
b.display();
b1.display();
b.move();
b1.move();
b.hover();
b1.hover();
}let ball = {
x:100,
y: 100,
d: 50,
xspeed:1,
yspeed:1
}
let beachBall = {
x: 50,
y: 50,
d: 100,
xspeed:1,
yspeed:1
}
function setup() {
createCanvas(400, 400);
}
function draw() {
background(220);
displayBall(ball);
displayBall(beachBall);
moveBall(ball);
moveBall(beachBall);
bounceBall(ball);
bounceBall(beachBall);
}
function displayBall(whichBall){
ellipse(whichBall.x, whichBall.y, whichBall.d, whichBall.d);
}
function moveBall(whichBall){
whichBall.x = whichBall.x + whichBall.xspeed;
whichBall.y = whichBall.y + whichBall.yspeed;
}
function bounceBall(whichBall){
if (whichBall.x <= 0 || whichBall.x >= width){
whichBall.xspeed= whichBall.xspeed * -1;
}
if (whichBall.y <= 0 || whichBall.y >= height){
whichBall.yspeed = whichBall.yspeed * -1;
}
}function setup() {
createCanvas(400, 400);
}
function draw() {
for (let i=0; i<100; i++){
drawCircle (random(-i,i),random(-i,i));
}
drawCircle(0,50);
drawCircle(70,60);
drawCircle(150,70);
let d = myDist (width/2 , height/2, mouseX, mouseY);
}
function drawCircle(offset,diameter){
fill(random(0,100),random(0,255),random(0,255));
ellipse(mouseX+offset, mouseY+offset,diameter,diameter);
}
function myDist (x1,y1,x2,y2) {
return sqrt(pow((x2 - x1),2)+pow((y2 -y1),2));
let slider;
let sliderC = 0;
let side = 600;
let black = 0;
function setup() {
createCanvas(side, side);
slider = padding  
}
function draw() {
for (let x = 0; x <= width; x += 25) {
rectMode(CENTER); 
if(sliderS < 10) { 
} else {
}
}
}
fill (255);
ellipseMode (CENTER);
ellipse (slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
}let padding = 50
let slider;
let sliderC = 0;
let side = 600;
let white = 255;
let black = 0;
function setup() {
frameRate(60);
createCanvas(side, side);
slider = padding
}
function draw() {
angleMode(DEGREES);
sliderC = map( slider, padding, width-padding, black, white);
sliderS = map( slider, padding, width-padding, 0, 20);
background(sliderC);
translate(width / 2, height / 2);
push();
rotate(180);
pop();
noFill();
for (let x = 0; x <= width; x += 20) {
for (let y = 0; y <= height; y += 20) {
rectMode(CENTER); 
fill (map(sliderC, black, white, white, black));
rect(x, y, sliderS,sliderS);
if(sliderS < 10) {
line(x, y, x+20, y+20);
} else {
line(x+20, y, x, y+20);
}
for (let y = 10; y <= height; y += 20) {
ellipseMode(CENTER); 
fill (map(sliderC, 0, 255, 255, 0));
ellipse(x, y, sliderS,sliderS);
}
translate(width / 2, height / 2);
push();
rotate(180);
pop();
} else {
translate(width / 2, height / 2);
push();
rotate(-180);
pop();
}
}
stroke (map(sliderC, black, white, white, black));
fill(255);
line( padding, height-padding, width-padding, height-padding)
ellipseMode (CENTER);
ellipse ( slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
}let padding = 50
let slider;
let sliderC = 0;
let side = 600;
function setup() {
frameRate(60);
createCanvas(side, side);
slider = padding
}
function draw() {
angleMode(DEGREES);
sliderC = map( slider, padding, width-padding, 0, 255);
sliderS = map( slider, padding, width-padding, 0, 20);
background(sliderC);
translate(width / 2, height / 2);
push();
rotate(180);
pop();
noFill();
for (let x = 0; x <= width; x += 20) {
for (let y = 0; y <= height; y += 20) {
rectMode(CENTER); 
fill (map(sliderC, 0, 255, 255, 0));
rect(x, y, sliderS,sliderS);
if(sliderS < 10) {
line(x, y, x+20, y+20);
} else {
line(x+20, y, x, y+20);
}
for (let x = 10; x <= width; x += 20) {
for (let y = 10; y <= height; y += 20) {
ellipseMode(CENTER); 
fill (map(sliderC, 0, 255, 255, 0));
ellipse(x, y, sliderS,sliderS);
}
}
translate(width / 2, height / 2);
push();
rotate(180);
pop();
} else {
translate(width / 2, height / 2);
push();
rotate(-180);
pop();
}
}
stroke (map(sliderC, 0, 255, 255, 0));
fill(255);
line( padding, height-padding, width-padding, height-padding)
ellipseMode (CENTER);
ellipse ( slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
}let padding = 50
let slider;
let sliderC = 0;
function setup() {
frameRate(60);
createCanvas(400, 400);
slider = padding
}
function draw() {
sliderC = map( slider, padding, width-padding, 0, 255);
sliderS = map( slider, padding, width-padding, 0, 20);
background(sliderC);
noFill();
for (let x = 0; x <= width; x += 20) {
for (let y = 0; y <= height; y += 20) {
ellipse(x,y,sliderS,sliderS);
if(sliderS < 10) {
line(x, y, x+20, y+20);
} else {
line(x+20, y, x, y+20);
}
}
}
stroke (map(sliderC, 0, 255, 255, 0));
fill(255);
line( padding, height-padding, width-padding, height-padding)
ellipseMode (CENTER);
ellipse ( slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
}let padding = 50
let slider;
let sliderC = 0;
function setup() {
frameRate(60);
createCanvas(400, 400);
slider = padding
}
function draw() {
sliderC = map( slider, padding, width-padding, 0, 255);
sliderS = map( slider, padding, width-padding, 0, 50);
background(sliderC);
noFill();
for (let x = 0; x <= width; x += 20) {
for (let y = 0; y <= height; y += 20) {
ellipse(x,y,sliderS,sliderS);
if(sliderS < 25) {
line(x, y, x+20, y+20);
} else {
line(x+random(20), y+random(20), x+random(20), y+random(20));
}
}
}
stroke (map(sliderC, 0, 255, 255, 0));
fill(255);
line( padding, height-padding, width-padding, height-padding)
ellipseMode (CENTER);
ellipse ( slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
}let padding = 50
let slider;
let sliderC = 0;
function setup() {
createCanvas(400, 400);
slider = padding
}
function draw() {
sliderC = map( slider, padding, width-padding, 0, 255); 
background(sliderC);
stroke (map(sliderC, 0, 255, 255, 0));
line( padding, height-padding, width-padding, height-padding)
ellipseMode (CENTER);
ellipse ( slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
for (let x = 0, x < width, x+= 10)
}let padding = 50
let slider;
let sliderC = 0;
function setup() {
createCanvas(400, 400);
slider = padding
}
function draw() {
sliderC = map( slider, padding, width-padding, 0, 255); 
background(sliderC);
stroke (map(sliderC, 0, 255, 255, 0));
line( padding, height-padding, width-padding, height-padding)
ellipseMode (CENTER);
ellipse ( slider, height-padding, 20,20);
if (mouseIsPressed && mouseY >= height-padding-10 && mouseY <= height-padding + 10) {
if (mouseX >= padding && mouseX <= width-padding ) {
slider = mouseX
}
}
}function setup() {
createCanvas(400, 400);
}
function draw() {
background(220);
let x = 0;
let y = 0;
while (c < 100){
ellipse (x,y,20,20);
x += 20;
y += 20;
c ++;
for (let c = 0; c < 200; c++){
ellipse (x,y,5,5);
x += 20;
y += 20;
c ++;
}
}let x, y;
let xdir = 4;
let ydir = 3;
let pxdir = 4;
let pydir = 3;
function setup() {
createCanvas(400, 400);
x= 10;
y= 10;
}
function draw() {
background(220);
rect (200,200,100,100);
if (mouseIsPressed){
if (mouseX > 200 && mouseX < 300 && mouseY > 200 && mouseY < 300){
xdir = x;
ydir = y;
} else {
xdir = pxdir;
ydir = pydir;
}
}
ellipse (x,y,20,20);
x = x + xdir;
y = y + ydir;
if (y>=height || y<= 0){
ydir = ydir * -1;
}
if (x>=width || x<= 0){
xdir = xdir * -1;
}
}let s = "";
let paragraph;
let charCount;
function setup() {
createCanvas(1, 1);
paragraph = createP("");
frameRate(10);
}
function draw() {
let x = random(width);
let y = random(height);
let c = random(96,123);
c = floor(c);
if (c==96 || charCount >= random (1,10)){
c=32
charCount=0;
}
c = char(c);
s = s + c;
charCount ++;
paragraph.html(s);
}let x, y;
let xdir = 4;
let ydir = 3;
function setup() {
createCanvas(400, 400);
x= 10;
y= 10;
}
function draw() {
background(220);
ellipse (x,y,20,20);
x = x + xdir;
y = y + ydir;
if (y>=height || y<= 0){
ydir = ydir * -1;
}
if (x>=width || x<= 0){
xdir = xdir * -1;
}
}let x,y;
function setup() {
createCanvas(400, 400);
let x =1;
if (x == true){
}
}
function draw() {
background(220);
var star;
function setup() {
createCanvas(side, side);
starX : mouseX,
starY : mouseY,
size : random(2,12)
}
}
function draw() {
fill(72,255,250);
strokeWeight(0);
locationX : random(width),
locationY : random(height),
size : random(1,8)
}
ellipseMode(CENTER); 
fill(74,156,255);
strokeWeight(0);
ellipse(star.starX, star.starY, star.size, star.size);
star.starY = star.starY-1;
}
function mousePressed() {
star = {
starX : mouseX,
starY : mouseY,
size : random(1,10)
}
}
var side = 600;
var star;
var fr=12
function setup() {
star = createCanvas(side, side);
star.mousePressed(daylight)
}
function draw() {
ellipseMode(CENTER); 
fill(72,255,250);
strokeWeight(0);
var x = random(width); 
var y = random(height);
var size = random(1,8)
ellipse(x, y, size, size);
background(0,0,0,20);
}
function daylight() {
ellipseMode(CENTER); 
fill(255);
strokeWeight(0);
var starX = mouseX;
var starY = mouseY;
var size = random(4,12); 
ellipse(starX, starY, size, size);
}
var starX = mouseX;
var starY = mouseY;
starX = starX+1; 
starY = starY-1;
let p;
function setup() {
createCanvas(400, 400);
p= createP("");
frameRate(1);
}
function draw() {
background(220);
let x = random(width); 
let y = random(height);
ellipse(x,y,50,50);
let c = random(96,127);
c = round(c);
c = char(c);
s = s + c;
}let x =1;
function setup() {
createCanvas(400, 400);
}
function draw() {
background(220);
ellipse(x,0,50,50)
x=x+1;
}function setup() {
createCanvas(626, 467);
background(43,255,254);
strokeWeight(40);
stroke(252,15,27);
line(0,0,626,467);
ellipseMode(CENTER);
fill(30,198,34);
strokeWeight(0);
ellipse(313,234,312,232);
rectMode(CENTER);
fill(2,13,126);
strokeWeight(0);
rect(449,214,40,40);
}
function draw() {
}function setup() {
createCanvas(600, 600);
}
function draw() {
background(220);
}function setup() {
createCanvas(400, 400);
}
function draw() {
background(220);
}  var x =1;
function setup() {
createCanvas(600, 700);
background(234);
ellipseMode(CENTER);
fill(104,72,54);
strokeWeight(0);
ellipse(300,175,138,222);
ellipseMode(CENTER);
fill(114,89,65);
strokeWeight(0);
ellipse(300,175,118,202);
ellipseMode(CENTER);
fill(104,72,54);
strokeWeight(0);
ellipse(300,175,110,190);
ellipseMode(CENTER);
fill(114,89,65);
strokeWeight(0);
ellipse(300,175,100,180);
rectMode(CENTER);
fill(234);
strokeWeight(0);
rect(300,258,130,57);
ellipseMode(CENTER);
fill(234,206,173);
strokeWeight(0);
ellipse(300,175,96,154);
strokeWeight(1);
stroke(234,206,173);
line(300,64,300,97);
ellipseMode(CENTER);
strokeWeight(3);
stroke(249,224,38);
noFill(); 
ellipse(248,204,10,70);
ellipseMode(CENTER);
strokeWeight(3);
stroke(249,224,38);
noFill(); 
ellipse(352,204,10,70);
rectMode(CENTER);
strokeWeight(2);
stroke(112,112,112);
noFill(); 
rect(322,146,32,24,3);
strokeWeight(0);
fill(255); 
arc(322, 150, 24, 22, PI, TWO_PI); 
fill(104,72,54);
ellipse(322, 145, 6, 6);
rectMode(CENTER);
strokeWeight(2);
stroke(112,112,112);
noFill(); 
rect(278,146,32,24,3);
strokeWeight(0);
fill(255); 
arc(278, 150, 24, 22, PI, TWO_PI); 
fill(104,72,54);
ellipse(278, 145, 6, 6);
strokeWeight(1);
stroke(112,112,112);
noFill(); 
arc(300, 150, 16, 12, PI+QUARTER_PI, TWO_PI-QUARTER_PI);
ellipseMode(CENTER);
strokeWeight(0);
fill(244,206,201); 
ellipse(278,198,24,32);
ellipseMode(CENTER);
strokeWeight(0);
fill(244,206,201); 
ellipse(322,198,24,32);
strokeWeight(2);
stroke(221,170,166);
noFill(); 
arc(300, 175, 10, 22, PI-HALF_PI, TWO_PI-HALF_PI);
strokeWeight(2);
stroke(221,170,166);
fill(255); 
arc(300, 200, 48, 45, 0, PI);
strokeWeight(1);
stroke(232,232,232);
fill(255); 
arc(300, 200, 46, 22, 0, PI);
strokeWeight(1);
stroke(232,232,232);
line(300,200,300,220);
rectMode(CENTER);
fill(234,206,173);
strokeWeight(0);
rect(300,256,26,30);
fill(234,206,173);
strokeWeight(0);
triangle(242,273,300,250,358,273);
strokeWeight(15);
stroke(234,206,173);
line(188,358,253,276);
strokeWeight(15);
stroke(234,206,173);
line(347,276,412,358);
fill(0);
strokeWeight(0);
triangle(242,273,300,426,358,273);
fill(0);
strokeWeight(0);
ellipse(271,273,58,16);
ellipse(329,273,58,16);
rectMode(CENTER);
fill(234,206,173);
strokeWeight(0);
rect(270,550,30,100);
rect(332,550,30,100);
fill(0);
strokeWeight(0);
triangle(187,506,300,309,413,506);
fill(0);
strokeWeight(0);
ellipse(215,505,56,16);
ellipse(272,505,56,16);
ellipse(329,505,56,16);
ellipse(386,505,56,16);
fill(0);
strokeWeight(0);
bezier(188, 505, 187, 475, 257, 358, 273, 358);
bezier(413, 506, 413, 475, 343, 358, 327, 358);
rectMode(CENTER);
fill(234,206,173);
strokeWeight(0);
rect(300,354,58,8);
strokeWeight(0);
fill(255); 
arc(270, 600, 52, 55, PI, TWO_PI);
fill(249); 
rect(270,606,58,12,3);
strokeWeight(0);
fill(255); 
arc(332, 600, 52, 55, PI, TWO_PI);
fill(249); 
rect(332,606,58,12,3);
}
function draw() {
ellipseMode(CENTER);
strokeWeight(3);
stroke(249,224,38);
noFill(); 
ellipse(x,204,50,50)
x=x+20;
}function setup() {
createCanvas(400, 400);
background(220);
fill(200,0,0);
ellipse(200,200,40,90);
stroke(0);
strokeWeight(3);
fill(0,0,200);
rect(180,50,50,50);
createP("My name is Vero");
}
function draw() {
}